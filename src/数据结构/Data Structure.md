# 一、排序算法

## 1.1、排序算法的稳定性及其汇总



同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的，否则就没有。



不具备稳定性的排序：

​	选择排序、快速排序、堆排序

具备稳定性的排序：

​	冒泡排序、插入排序、归并排序、一切桶排序思想下的排序



目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。

|                    | 时间复杂度    | 空间复杂度  | 是否具有稳定性 |
| ------------------ | ------------- | ----------- | -------------- |
| 选择               | $$O(n^2)$$    | $$O(1)$$    | ×              |
| 冒泡               | $$O(n^2)$$    | $$O(1)$$    | √              |
| 插入               | $$O(n^2)$$    | $$O(1)$$    | √              |
| 归并               | $$O(N*logN)$$ | $$O(N)$$    | √              |
| 快排（随）优先选择 | $$O(N*logN)$$ | $$O(logN)$$ | ×              |
| 堆                 | $$O(N*logN)$$ | $$O(1)$$    | ×              |



常见的坑：

1. 归并排序的额外空间复杂度可以变成0(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序内部缓存法”
   - 是可以的，但是不再稳定，而且实现困难。可以使用堆排序代替。
2. “原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成0(N^2)
   - 可以使用插入排序代替
3. 快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜“01 stable sort"
   - 是可以的，但是使得快排空间复杂度变成0(N) ，可以使用 归并排序实现
4. 所有的改进都不重要，因为目前没有找到时间复杂度0(N*logN)，额外空间复杂度0(1)，又稳定的排序。
5. 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官。
   - 经典快排的 partition 做不到稳定性，快排的 partition 也是0，1标准，他和奇偶问题是一种调整策略，快排做不到。所以请教一下这题怎么解。





# 二、堆（logN）

堆是完全二叉树。

完全二叉树：从左到右依次生成。

大根堆，顶层为最大值。

小根堆，顶层为最小值。

子节点的位置如果不符合大根堆要和父节点进行比较 ( $$\frac{i-1}{2}$$ ) 依次往上换，保证顶部是最大值。

优先级队列结构，就是堆结构。

> 从下到上 heapInsert
>
> 从上到下 heapify

```java
// 增加新数字的时候
public static void heapInsert(int[] arr, int index){
	while(arr[index] > arr[( index - 1 ) / 2 ]){
   	swap(arr, index, (index - 1)/2);
    index = (index - 1)/2;
  }
}
```

```java
// 减少数字的时候
// 某个数在 index 位置，能否往下移动
public static void heapify(int[] arr, int index, int heapSize){
	int left = index * 2 + 1; // 左孩子的下标
  while(left < heapSize){ // 下方还有孩子的时候
    // 两个孩子中，谁的值大，把下标给 largest
    int largest = left + 1 < heapSize && arr[left + 1] > arr[left]
							      ? left + 1 : left;
    // 父和孩子之间，谁的值大，把下标给 largest
    largest = arr[largest] > arr[index] ? largest : index;
    if (largest == index){
      break;
		}
    swap(arr, largest, index);
    index = largest;
    left = index * 2 + 1;
  }
}

```



# 三、哈希表

哈希表的简单介绍

1. 哈希表在使用层面上可以理解为一种集合结构

2. 如果只有key，没有伴随数据value，可以使用HashSet结构(C++中叫UnOrderedSet)

3. 如果既有key，又有伴随数据value，可以使用HashMap结构(C++中叫UnOrderedMap)

4. 有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事

5. 使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为0(1)，但是常数时间比较大

6. 放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小

7. 放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小
   有关哈希表的原理，将在提升班“与哈希函数有关的数据结构”一章中讲叙原理

   - 如果存储的是原始类型 例如： int，string....，哈希表会拷贝一份作为key

   - 如果存储的是自定义类型 哈希表会引用 对应的内存地址作为 key 只占 8 个字节

哈希表的操作都是 O( C ) ，C 是 比较大的常数项



# 四、有序表

有序表的简单介绍

1. 有序表在使用层面上可以理解为一种集合结构

2. 如果只有key，没有伴随数据value，可以使用TreeSet结构(C++中叫OrderedSet)

3. 如果既有key，又有伴随数据value，可以使用TreeMap结构(C++中叫OrderedMap)

4. 有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事

      有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织
          红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同

5. 放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小

6. 放入哈希表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小

7. 不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度

有序表的所有操作时间复杂度都是 O( logN )，N 为有序表含有的记录数。

哈希表是无序的，有序表是有序的。



# 五、链表

- #### 单链表的节点结构

```
Class Node<V>{
	V value;
	Node next;
}
```

由以上结构的节点一次连接起来所形成的链叫单链表结构。



- #### 双链表的节点结构

```
Class Node<V>{
	V value;
	Node next;
	Node last;
}
```

由以上结构的节点依次连接起来所形成的链叫双链表

单链表和双链表结构只需要给定一个头部节点 head，就可以找到剩下的所有的节点。



面试时链表解题的方法论

1. 对于笔试，不用太在乎空间复杂度，一切为了时间复杂度。
2. 对于面试，时间复杂度依旧放在第一位，但是一定要找到空间最省的方法。



重要技巧：

1. 额外数据结构记录（哈希表等）
2. 快慢指针



### 1、练习题目

- 判断一个链表是否为回文结构

  > 【题目】给定一个单链表的头节点 head，请判断该链表是否为回文结构
  >
  > 【例子】1 -> 2 -> 1 返回 true；1 -> 2 -> 3 返回 false
  >
  > 【例子】如果链表长度为 N，时间复杂度达到 O(N)，额外空间复杂度达到 O( 1 )。





# 三、比较器(java说法)

比较器的使用

1. 比较器的实质就是(c++说法: 重载比较运算符 )。
2. 比较器可以很好的应用在特殊标准的排序上。
3. 比较器可以很好的应用在根据特殊标准排序的结构上。



```java
public static class AComp implements Comparator<Integer>{

  // 比较器用法
  // 如果返回负数，认为第一个参数应该放在上面
  // 如果返回正数，认为第二个参数应该放在上面
  // 如果返回0，认为谁放上面都行
  @Override
  public int compare(Integer arg0, Integer arg1){
    return  arg1 - arg0;
  }
}

public static void main(String[] args){
  PriorityQueue<Integer> heap = new PriorityQueue<>(new AComp());

  heap.add(6);
  heap.add(9);
  heap.add(3);
  heap.add(2);
  heap.add(10);

  while (!heap.isEmpty()) {
    System.out.println(heap.poll());
  }
}
```

